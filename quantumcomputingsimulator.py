# -*- coding: utf-8 -*-
"""QuantumComputingSimulator.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AqVhZ7TdMlYT51AIUzeDuP75LBE3mjug
"""

# Step 1: Install necessary libraries
!pip install pennylane chembl-webresource-client rdkit

# Step 2: Import libraries
import pennylane as qml
from pennylane import numpy as np
from chembl_webresource_client.new_client import new_client
from rdkit import Chem
from rdkit.Chem import AllChem
import matplotlib.pyplot as plt

# Step 3: Fetch and prepare the dataset
molecule = new_client.molecule
molecule_list = molecule.filter(
    molecule_properties__num_ro5_violations=0
).only('molecule_chembl_id', 'molecule_structures')[:10]
smiles_list = [mol['molecule_structures']['canonical_smiles'] for mol in molecule_list]
rdkit_molecules = [Chem.MolFromSmiles(smile) for smile in smiles_list]
for mol in rdkit_molecules[:3]:
    display(mol)

# Step 4: Generate molecular Hamiltonian
def generate_hamiltonian(molecule):
    molecule = Chem.AddHs(molecule)
    AllChem.EmbedMolecule(molecule)
    AllChem.UFFOptimizeMolecule(molecule)
    num_qubits = 2
    hamiltonian = np.array([[1.0, 0.0, 0.0, 0.0], [0.0, -1.0, 0.0, 0.0],
                            [0.0, 0.0, 1.0, 0.0], [0.0, 0.0, 0.0, -1.0]])
    return num_qubits, hamiltonian

num_qubits, hamiltonian = generate_hamiltonian(rdkit_molecules[0])
print(f"Number of qubits: {num_qubits}")
print(f"Hamiltonian:\n{hamiltonian}")

# Step 5: Quantum simulation
def run_quantum_simulation(num_qubits, hamiltonian):
    dev = qml.device('default.qubit', wires=num_qubits)

    @qml.qnode(dev)
    def circuit():
        qml.Hadamard(wires=0)
        qml.CNOT(wires=[0, 1])
        qml.QubitUnitary(hamiltonian, wires=range(num_qubits))
        return qml.probs(wires=range(num_qubits))

    probs = circuit()
    return probs
probs = run_quantum_simulation(num_qubits, hamiltonian)
plt.bar(range(len(probs)), probs)
plt.show()

# Step 6: Analyze results
def analyze_results(probs):
    print("Quantum Simulation Results:")
    for i, prob in enumerate(probs):
        print(f"State {bin(i)[2:]:>0{num_qubits}}: {prob*100:.2f}%")

    plt.bar(range(len(probs)), probs)
    plt.xlabel('State')
    plt.ylabel('Probability')
    plt.show()

analyze_results(probs)

# Step 7: Putting it all together
def quantum_molecular_modeling(smiles):
    molecule = Chem.MolFromSmiles(smiles)
    num_qubits, hamiltonian = generate_hamiltonian(molecule)
    probs = run_quantum_simulation(num_qubits, hamiltonian)
    analyze_results(probs)

quantum_molecular_modeling(smiles_list[0])





